<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="English">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="LCT NotePreface准备学个数据结构来回升一下状态。LCT的题很多 前置知识实链剖分，Splay，势能分析。 Splay以前没写过具体的会详细说明。 有个大胆的想法，我准备把之前关于Splay的介绍都放过来，呈现一个更加完善的学习笔记。 原始论文From Tarjan and else… dynamic-trees.pdf 还参考了 https://www.cnblogs.com/can">
<meta name="keywords" content="LCT">
<meta property="og:type" content="article">
<meta property="og:title" content="LCT Note">
<meta property="og:url" content="http://yoursite.com/2019/03/31/LCT Note/index.html">
<meta property="og:site_name" content="L1ght">
<meta property="og:description" content="LCT NotePreface准备学个数据结构来回升一下状态。LCT的题很多 前置知识实链剖分，Splay，势能分析。 Splay以前没写过具体的会详细说明。 有个大胆的想法，我准备把之前关于Splay的介绍都放过来，呈现一个更加完善的学习笔记。 原始论文From Tarjan and else… dynamic-trees.pdf 还参考了 https://www.cnblogs.com/can">
<meta property="og:locale" content="English">
<meta property="og:image" content="http://yoursite.com/images/Splay1.bmp">
<meta property="og:image" content="http://yoursite.com/images/Splay2.png">
<meta property="og:image" content="http://yoursite.com/images/Splay3.png">
<meta property="og:image" content="http://yoursite.com/images/splay_t_1.png">
<meta property="og:image" content="http://yoursite.com/images/splay_t_2.png">
<meta property="og:image" content="http://yoursite.com/images/splay_t_3.png">
<meta property="og:image" content="http://yoursite.com/images/lct_1.png">
<meta property="og:image" content="http://yoursite.com/images/lct_2.png">
<meta property="og:image" content="http://yoursite.com/images/lct_3.png">
<meta property="og:image" content="http://yoursite.com/images/lct_4.png">
<meta property="og:image" content="http://yoursite.com/images/lct_5.png">
<meta property="og:image" content="http://yoursite.com/images/lct_10.png">
<meta property="og:image" content="http://yoursite.com/images/lct_6.png">
<meta property="og:image" content="http://yoursite.com/images/lct_7.png">
<meta property="og:image" content="http://yoursite.com/images/lct_8.png">
<meta property="og:image" content="http://yoursite.com/images/lct_9.png">
<meta property="og:updated_time" content="2019-05-22T10:01:25.063Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LCT Note">
<meta name="twitter:description" content="LCT NotePreface准备学个数据结构来回升一下状态。LCT的题很多 前置知识实链剖分，Splay，势能分析。 Splay以前没写过具体的会详细说明。 有个大胆的想法，我准备把之前关于Splay的介绍都放过来，呈现一个更加完善的学习笔记。 原始论文From Tarjan and else… dynamic-trees.pdf 还参考了 https://www.cnblogs.com/can">
<meta name="twitter:image" content="http://yoursite.com/images/Splay1.bmp">






  <link rel="canonical" href="http://yoursite.com/2019/03/31/LCT Note/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>LCT Note | L1ght</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="English">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">L1ght</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">nothing</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section">&lt;i class&#x3D;&quot;menu-item-icon fa fa-fw fa-home&quot;&gt;&lt;&#x2F;i&gt; &lt;br &#x2F;&gt;Startseite</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section">&lt;i class&#x3D;&quot;menu-item-icon fa fa-fw fa-archive&quot;&gt;&lt;&#x2F;i&gt; &lt;br &#x2F;&gt;Archiv</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Suche</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/31/LCT Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wavwing">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="L1ght">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">LCT Note
              
            
          </h1>
        

        <div class="post-meta">
		
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2019-03-31 00:00:00" itemprop="dateCreated datePublished" datetime="2019-03-31T00:00:00+08:00">2019-03-31</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2019-05-22 18:01:25" itemprop="dateModified" datetime="2019-05-22T18:01:25+08:00">2019-05-22</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="LCT-Note"><a href="#LCT-Note" class="headerlink" title="LCT Note"></a>LCT Note</h1><h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>准备学个数据结构来回升一下状态。<del>LCT的题很多</del></p>
<p>前置知识实链剖分，Splay，势能分析。</p>
<p>Splay以前没写过具体的会详细说明。</p>
<p>有个大胆的想法，我准备把之前关于Splay的介绍都放过来，呈现一个更加完善的学习笔记。</p>
<p>原始论文From Tarjan and else…</p>
<p><a href="/download/dynamic-trees.pdf">dynamic-trees.pdf</a></p>
<p>还参考了</p>
<p><a href="https://www.cnblogs.com/candy99/p/6271344.html" target="_blank" rel="noopener">https://www.cnblogs.com/candy99/p/6271344.html</a></p>
<p><a href="https://oi-wiki.org/ds/lct/" target="_blank" rel="noopener">https://oi-wiki.org/ds/lct/</a></p>
<p><del>大概要学到明天</del></p>
<h3 id="动态树原始问题："><a href="#动态树原始问题：" class="headerlink" title="动态树原始问题："></a>动态树原始问题：</h3><p>维护一个森林, 支持删除某条边，加⼊某条边，并保证加边，删边之后仍是森林。我们要维护这个森林的一些信息。<br>一般的操作有两点连通性，两点路径权值和，连接两点和切断某条边、修改信息等。</p>
<p><strong>可以解决这些问题：</strong></p>
<ol>
<li>查询一个点的父亲</li>
<li>查询一个点所在的树的根</li>
<li>修改某个节点的权</li>
<li>向从某个节点到它所在的树的根的路径上的所有的节点的权增加一个数</li>
<li>查询从某个节点到它所在的树的根的路径上的所有的节点的权的最小值</li>
<li>把一棵树从某个节点和它的父亲处断开，使其成为两棵树</li>
<li>让一棵树的根成为另一棵树的某个节点的儿子，从而合并这两棵树</li>
<li>把某棵树的根修改为它的某个节点</li>
<li>查询在同一棵树上的两个节点的LCA（动态LCA）</li>
<li>修改以某个节点为根的子树的所有节点的权</li>
<li>查询以某个节点为根的子树的所有节点的权的最小值</li>
</ol>
<p>注意涉及到子树的问题可能需要一些补充和拓展（比如AAA树甚至Top Tree），在将来会补充。</p>
<h2 id="前置知识篇"><a href="#前置知识篇" class="headerlink" title="前置知识篇"></a>前置知识篇</h2><h3 id="实链剖分"><a href="#实链剖分" class="headerlink" title="实链剖分"></a>实链剖分</h3><p>对于每个点选中一个重儿子，其他为轻儿子。</p>
<p>具体好在哪里还是看后面吧。。</p>
<h2 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h2><p>回家后补上完整的学习资料。</p>
<h3 id="Splay基本操作"><a href="#Splay基本操作" class="headerlink" title="Splay基本操作"></a>Splay基本操作</h3><h3 id="变量声明："><a href="#变量声明：" class="headerlink" title="变量声明："></a>变量声明：</h3><p>f[i]表示i的父结点，</p>
<script type="math/tex; mode=display">
ch_{i,0}</script><p><strong>表示i的左儿子，</strong></p>
<script type="math/tex; mode=display">
ch_{i,1}</script><p><strong>表示i的右儿子</strong> , $key_i$表示i的关键字（即结点i代表的那个数字），$cnt_i$表示$i$结点的关键字出现的次数（相当于权值），$size_i$表示包括i的这个子树的大小；$sz$为整棵树的大小，$root$为整棵树的根。</p>
<hr>
<h3 id="【clear操作】"><a href="#【clear操作】" class="headerlink" title="【clear操作】"></a>【clear操作】</h3><p>将当前点的各项值都清0（用于删除之后）,时间复杂度$O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">     ch[x][<span class="number">0</span>]=ch[x][<span class="number">1</span>]=f[x]=cnt[x]=key[x]=size[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【get操作】"><a href="#【get操作】" class="headerlink" title="【get操作】"></a>【get操作】</h3><p>判断当前点是它父结点的左儿子还是右儿子，时间复杂度$O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> ch[f[x]][<span class="number">1</span>]==x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【update操作】："><a href="#【update操作】：" class="headerlink" title="【update操作】："></a>【update操作】：</h3><p>更新当前点的size值（用于发生修改之后） ,时间复杂度$O(1)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (x)&#123;</span><br><span class="line">          <span class="built_in">size</span>[x]=cnt[x];</span><br><span class="line">          <span class="keyword">if</span> (ch[x][<span class="number">0</span>]) <span class="built_in">size</span>[x]+=<span class="built_in">size</span>[ch[x][<span class="number">0</span>]];</span><br><span class="line">          <span class="keyword">if</span> (ch[x][<span class="number">1</span>]) <span class="built_in">size</span>[x]+=<span class="built_in">size</span>[ch[x][<span class="number">1</span>]];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【旋转操作】："><a href="#【旋转操作】：" class="headerlink" title="【旋转操作】："></a>【旋转操作】：</h3><p>务必完全理解这个操作，这是平衡树最重要的，复杂度得到保证的操作</p>
<p>【rotate操作图文详解】</p>
<p><img src="/images/Splay1.bmp" alt="img"></p>
<p>这是原来的树，假设我们现在要将D结点rotate到它的父亲的位置。</p>
<ul>
<li>step 1：</li>
</ul>
<p>找出D的父亲结点（B）以及父亲的父亲（A）并记录。判断D是B的左结点还是右结点。</p>
<ul>
<li>step 2：</li>
</ul>
<p>我们知道要将Drotate到B的位置，二叉树的大小关系不变的话，B就要成为D的右结点了没错吧？</p>
<p>咦？可是D已经有右结点了，这样不就冲突了吗？怎么解决这个冲突呢？</p>
<p>我们知道，D原来是B的左结点，那么rotate过后B就一定没有左结点了对吧，那么正好，我们把G接到B的左结点去，并且这样大小关系依然是不变的，就完美的解决了这个冲突。如下图。</p>
<p><img src="/images/Splay2.png" alt="Splay2"></p>
<p><img src="/images/Splay3.png" alt="Splay3"></p>
<p>这样我们就完成了一次rotate，如果是右儿子的话同理。step 2的具体操作：</p>
<p>我们已经判断了D是B的左儿子还是右儿子，设这个关系为K；将D与K关系相反的儿子的父亲记为B与K关系相同的儿子（这里即为D的右儿子的父亲记为B的左儿子）；将D与K关系相反的儿子的父亲即为B（这里即为把G的父亲记为B）；将B的父亲即为D；将D与K关系相反的儿子记为B（这里即为把D的右儿子记为B）；将D的父亲记为A。</p>
<p>最后要判断，如果A存在（即rotate到的位置不是根的话），要把A的儿子即为D。</p>
<p>显而易见，rotate之后所有牵涉到变化的父子关系都要改变。以上的树需要改变四对父子关系，BG DG BD AB，需要三个操作（BG BD AB）。</p>
<ul>
<li>step 3：update一下当前点和各个父结点的各个值</li>
</ul>
<p>以前Treap我写旋转都是左旋右旋分开写。。想必看了上面的图不难发现规律并把两个写在一起。</p>
<p>并且不要漏了某些父子关系忘了修改，显然比递归传址维护父子麻烦点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> old=f[x],oldf=f[old],which=<span class="built_in">get</span>(x);</span><br><span class="line">     ch[old][which]=ch[x][which^<span class="number">1</span>];f[ch[old][which]]=old;</span><br><span class="line">     f[old]=x;ch[x][which^<span class="number">1</span>]=old;</span><br><span class="line">     f[x]=oldf;</span><br><span class="line">     <span class="keyword">if</span> (oldf)</span><br><span class="line">          ch[oldf][ch[oldf][<span class="number">1</span>]==old]=x;</span><br><span class="line">     update(old);update(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是Splay操作，大致和Treap一样但是好像需要分更多情况讨论一下。</p>
<h3 id="【Splay操作】"><a href="#【Splay操作】" class="headerlink" title="【Splay操作】"></a>【Splay操作】</h3><p>其实splay只是rotate的发展。伸展操作只是在不停的rotate，一直到达到目标状态。如果有一个确定的目标状态，也可以传两个参。此代码直接splay到根。</p>
<p>splay的过程中需要分类讨论，如果是三点一线的话（x，x的父亲，x的祖父）需要先rotate x的父亲，否则需要先rotate x本身（否则会形成单旋使平衡树失衡）（这东西还需要再去了解一下）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> fa;(fa=f[x]);rotate(x))</span><br><span class="line">          <span class="keyword">if</span> (f[fa])</span><br><span class="line">               rotate((<span class="built_in">get</span>(x)==<span class="built_in">get</span>(fa)?fa:x));</span><br><span class="line">     root=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【insert操作】"><a href="#【insert操作】" class="headerlink" title="【insert操作】"></a>【insert操作】</h3><p>其实插入操作是比较简单的，和普通的二叉查找树基本一样。</p>
<p>step 1：如果root=0，即树为空的话，做一些特殊的处理，直接返回即可。</p>
<p>step 2：按照二叉查找树的方法一直向下找，其中：</p>
<p>如果遇到一个结点的关键字等于当前要插入的点的话，我们就等于把这个结点加了一个权值。因为在二叉搜索树中是不可能出现两个相同的点的。并且要将当前点和它父亲结点的各项值更新一下。做一下splay。</p>
<p>如果已经到了最底下了，那么就可以直接插入。整个树的大小要+1，新结点的左儿子右儿子（虽然是空）父亲还有各项值要一一对应。并且最后要做一下他父亲的update（做他自己的没有必要）。做一下splay。！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (root==<span class="number">0</span>) </span><br><span class="line">     &#123;sz++;ch[sz][<span class="number">0</span>]=ch[sz][<span class="number">1</span>]=f[sz]=<span class="number">0</span>;key[sz]=v;cnt[sz]=<span class="number">1</span>;<span class="built_in">size</span>[sz]=<span class="number">1</span>;root=sz;<span class="keyword">return</span>;&#125;</span><br><span class="line">     <span class="keyword">int</span> now=root,fa=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span> (key[now]==v)&#123;</span><br><span class="line">               cnt[now]++;update(now);update(fa);splay(now);<span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          fa=now;</span><br><span class="line">          now=ch[now][key[now]&lt;v];</span><br><span class="line">          <span class="keyword">if</span> (now==<span class="number">0</span>)&#123;</span><br><span class="line">               sz++;</span><br><span class="line">               ch[sz][<span class="number">0</span>]=ch[sz][<span class="number">1</span>]=<span class="number">0</span>;key[sz]=v;<span class="built_in">size</span>[sz]=<span class="number">1</span>;</span><br><span class="line">               cnt[sz]=<span class="number">1</span>;f[sz]=fa;ch[fa][key[fa]&lt;v]=sz;</span><br><span class="line">               update(fa);</span><br><span class="line">               splay(sz);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【find操作】"><a href="#【find操作】" class="headerlink" title="【find操作】"></a>【find操作】</h3><p>查询x的排名</p>
<p>初始化：ans=0，当前点=root</p>
<p>和其它二叉搜索树的操作基本一样。但是区别是：</p>
<p>如果x比当前结点小，即应该向左子树寻找，ans不用改变（设想一下，走到整棵树的最左端最底端排名不就是1吗）。</p>
<p>如果x比当前结点大，即应该向右子树寻找，ans需要加上左子树的大小以及根的大小（这里的大小指的是权值）。</p>
<p>不要忘记了再splay一下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> ans=<span class="number">0</span>,now=root;</span><br><span class="line">     <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span> (v&lt;key[now])</span><br><span class="line">               now=ch[now][<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">else</span>&#123;</span><br><span class="line">               ans+=(ch[now][<span class="number">0</span>]?<span class="built_in">size</span>[ch[now][<span class="number">0</span>]]:<span class="number">0</span>);</span><br><span class="line">               <span class="keyword">if</span> (v==key[now]) &#123;splay(now);<span class="keyword">return</span> ans+<span class="number">1</span>;&#125;</span><br><span class="line">               ans+=cnt[now];</span><br><span class="line">               now=ch[now][<span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【findx操作】"><a href="#【findx操作】" class="headerlink" title="【findx操作】"></a>【findx操作】</h3><p>找到排名为x的点</p>
<p>初始化：当前点=root</p>
<p>和上面的思路基本相同：</p>
<p>如果当前点有左子树，并且x比左子树的大小小的话，即向左子树寻找；</p>
<p>否则，向右子树寻找：先判断是否有右子树，然后记录右子树的大小以及当前点的大小（都为权值），用于判断是否需要继续向右子树寻找。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">findx</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> now=root;</span><br><span class="line">     <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span> (ch[now][<span class="number">0</span>]&amp;&amp;x&lt;=<span class="built_in">size</span>[ch[now][<span class="number">0</span>]])</span><br><span class="line">               now=ch[now][<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">int</span> temp=(ch[now][<span class="number">0</span>]?<span class="built_in">size</span>[ch[now][<span class="number">0</span>]]:<span class="number">0</span>)+cnt[now];</span><br><span class="line">              <span class="keyword">if</span> (x&lt;=temp)&#123;</span><br><span class="line">                  splay(now);</span><br><span class="line">                  <span class="keyword">return</span> key[now];</span><br><span class="line">              &#125;</span><br><span class="line">               x-=temp;now=ch[now][<span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【pre-next操作】"><a href="#【pre-next操作】" class="headerlink" title="【pre/next操作】"></a>【pre/next操作】</h3><p>这个操作十分的简单，只需要理解一点：在我们做insert操作之后做了一遍splay。这就意味着我们把x已经splay到根了。求x的前驱其实就是求x的左子树的最右边的一个结点，后继是求x的右子树的左边一个结点（想一想为什么？）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> now=ch[root][<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">while</span> (ch[now][<span class="number">1</span>]) now=ch[now][<span class="number">1</span>];</span><br><span class="line">     <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> now=ch[root][<span class="number">1</span>];</span><br><span class="line">     <span class="keyword">while</span> (ch[now][<span class="number">0</span>]) now=ch[now][<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【del操作】"><a href="#【del操作】" class="headerlink" title="【del操作】"></a>【del操作】</h3><p>删除操作是最后一个稍微有点麻烦的操作。</p>
<p>step 1：随便find一下x。目的是：将x旋转到根。</p>
<p>step 2：那么现在x就是根了。如果cnt[root]&gt;1，即不只有一个x的话，直接-1返回。</p>
<p>step 3：如果root并没有孩子，就说名树上只有一个x而已，直接clear返回。</p>
<p>step 4：如果root只有左儿子或者右儿子，那么直接clear root，然后把唯一的儿子当作根就可以了（f赋0，root赋为唯一的儿子）</p>
<p>剩下的就是它有两个儿子的情况。</p>
<p>step 5：我们找到新根，也就是x的前驱（x左子树最大的一个点），将它旋转到根。然后将原来x的右子树接到新根的右子树上（注意这个操作需要改变父子关系）。这实际上就把x删除了。不要忘了update新根。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> whatever=<span class="built_in">find</span>(x);</span><br><span class="line">     <span class="keyword">if</span> (cnt[root]&gt;<span class="number">1</span>) &#123;cnt[root]--;update(root);<span class="keyword">return</span>;&#125;</span><br><span class="line">     <span class="comment">//Only One Point</span></span><br><span class="line">     <span class="keyword">if</span> (!ch[root][<span class="number">0</span>]&amp;&amp;!ch[root][<span class="number">1</span>]) &#123;<span class="built_in">clear</span>(root);root=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">     <span class="comment">//Only One Child</span></span><br><span class="line">     <span class="keyword">if</span> (!ch[root][<span class="number">0</span>])&#123;</span><br><span class="line">          <span class="keyword">int</span> oldroot=root;root=ch[root][<span class="number">1</span>];f[root]=<span class="number">0</span>;<span class="built_in">clear</span>(oldroot);<span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (!ch[root][<span class="number">1</span>])&#123;</span><br><span class="line">          <span class="keyword">int</span> oldroot=root;root=ch[root][<span class="number">0</span>];f[root]=<span class="number">0</span>;<span class="built_in">clear</span>(oldroot);<span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//Two Children</span></span><br><span class="line">     <span class="keyword">int</span> leftbig=pre(),oldroot=root;</span><br><span class="line">     splay(leftbig);</span><br><span class="line">     f[ch[oldroot][<span class="number">1</span>]]=root;</span><br><span class="line">     ch[root][<span class="number">1</span>]=ch[oldroot][<span class="number">1</span>];</span><br><span class="line">     <span class="built_in">clear</span>(oldroot);</span><br><span class="line">     update(root);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Splay区间翻转"><a href="#Splay区间翻转" class="headerlink" title="Splay区间翻转"></a>Splay区间翻转</h3><p>显然在Splay基本操作讲清楚了，又有如下几个问题</p>
<ul>
<li>求x的前驱其实就是求x的左子树的最右边的一个结点，后继是求x的右子树的左边一个结点（想一想为什么？）</li>
</ul>
<p>答案非常简单，如果我们把x先插入旋转到根上，左子树全部不大于x，右子树全部不小于x，左子树最右边节点保证在左子树内最大，右子树最左边节点同理。不大于x的最大值与不小于x的最小值就是前驱后继的定义（不过有可能重复）。</p>
<ul>
<li>为什么Splay提取一个区间是将区间左端点的前驱旋转至根，右端点后继旋转至根的右儿子，右儿子的左子树就是区间呢？</li>
</ul>
<p>这个问题非常重要，是区间操作的基本原理。</p>
<p>显然第一次旋转后左端点在根的右子树，第二次旋转后右端点在根的右儿子的左子树，在区间(L,R)内，任何一个节点既不能在根的左子树（BST性质，它们大于左端点），又不能在根的右儿子的右子树（同样不能大于右端点），因此整个闭区间所有节点都在根的右儿子的左子树内了！</p>
<ul>
<li>还有个我认为非常难证明的问题，就是为什么懒标记是正确的。。。线段树懒标记正确在于它的形态是不会发生改变的，显然每个节点代表了固定的区间。但是Splay显然作为子树的根的节点只是临时的，那会不会造成错误的标记呢？</li>
</ul>
<p>这个问题让我想了半天。实际上是这样的。考虑暴力Splay翻转区间是从根的右儿子的左儿子u开始，对于每个节点我们都交换左右子树，这相当于一组操作。<strong>显然只要我们没有访问一个点，它的子树交不交换并没有什么区别。</strong>也就是说我们没必要重复交换，只需要在访问的时候确保进行操作并下传标记即可。那么对于当前根，我们交换子树并给这个点打上标记，后面只要访问到这个点就下推标记并操作，这样确保每个该翻转的子树翻转了，也能优化复杂度（具体严格复杂度证明以后补上吧）。</p>
<p>总结一下这个问题就是：只要子树不旋转，这个子树的根就不pushdown，这其实就是懒标记的思想，尽管Splay不像线段树形态固定，只要遵循这一原则就一定不会出错。</p>
<p>上述问题都理解了的话，一遍写过Splay十分轻松（97行）</p>
<p>那么区间操作也不是很难了，我们只需要在提取的区间根节点交换左右儿子并打上懒标记即可。</p>
<p>区间操作Splay（只有翻转操作，其它的也差不多）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7ffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls s[node][0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs s[node][1] </span></span><br><span class="line"><span class="keyword">int</span> f[maxn] , s[maxn][<span class="number">2</span>] , key[maxn] , val[maxn] , n , m , sz[maxn] , rev[maxn] , tot, root;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(node)&#123;</span><br><span class="line">		sz[node] = <span class="number">1</span>;</span><br><span class="line">		sz[node] += sz[ls];</span><br><span class="line">		sz[node] += sz[rs];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(node &amp;&amp; rev[node])</span><br><span class="line">	&#123;</span><br><span class="line">		rev[node] = <span class="number">0</span>;</span><br><span class="line">		rev[ls] ^= <span class="number">1</span>;</span><br><span class="line">		rev[rs] ^= <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">std</span>::swap(ls , rs);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s[f[node]][<span class="number">1</span>] == node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fx = f[node] , ffx = f[fx] , son = get(node);</span><br><span class="line">	s[fx][son] = s[node][son^<span class="number">1</span>] , f[s[node][son^<span class="number">1</span>]] = fx;</span><br><span class="line">	f[node] = ffx ;</span><br><span class="line">   	<span class="keyword">if</span>(ffx)	s[ffx][s[ffx][<span class="number">1</span>]==fx] = node;</span><br><span class="line">	s[node][son^<span class="number">1</span>] = fx , f[fx] = node;</span><br><span class="line">	update(node) , update(fx) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> fx ; (fx = f[x]) != pos ; rotate(x))</span><br><span class="line">		<span class="keyword">if</span>(f[fx] != pos)</span><br><span class="line">			rotate((get(x) == get(fx))? fx : x);</span><br><span class="line">	<span class="keyword">if</span>(!pos) root = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> fx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span> , node = ++tot;</span><br><span class="line">	key[node] = val[mid];</span><br><span class="line">	f[node] = fx;</span><br><span class="line">	ls = build(l , mid - <span class="number">1</span> , node);</span><br><span class="line">	rs = build(mid + <span class="number">1</span> , r , node);</span><br><span class="line">	update(node);</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> node = root;</span><br><span class="line">	<span class="keyword">while</span>(node)</span><br><span class="line">	&#123;</span><br><span class="line">		pushdown(node);</span><br><span class="line">		<span class="keyword">if</span>(k &lt;= sz[ls]) node = ls;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			k -= sz[ls] + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(!k) <span class="keyword">return</span> node;</span><br><span class="line">			node = rs;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pushdown(node);</span><br><span class="line">	<span class="keyword">if</span>(ls) print(ls);</span><br><span class="line">	<span class="keyword">if</span>(key[node] != -INF &amp;&amp; key[node] != INF) <span class="built_in">printf</span>(<span class="string">"%d "</span>,key[node]);</span><br><span class="line">	<span class="keyword">if</span>(rs) print(rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	val[<span class="number">1</span>] = -INF , val[n+<span class="number">2</span>] = INF;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n + <span class="number">1</span> ; ++i)</span><br><span class="line">		val[i] = i<span class="number">-1</span>;</span><br><span class="line">	root = build(<span class="number">1</span> , n + <span class="number">2</span> , <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span>(~(--m))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> l , r;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">		<span class="keyword">int</span> posl = find(l) , posr = find(r+<span class="number">2</span>);</span><br><span class="line">		splay(posl , <span class="number">0</span>);</span><br><span class="line">		splay(posr , posl);</span><br><span class="line">		rev[s[s[root][<span class="number">1</span>]][<span class="number">0</span>]] ^= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	print(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="摊还分析与Splay的复杂度证明"><a href="#摊还分析与Splay的复杂度证明" class="headerlink" title="摊还分析与Splay的复杂度证明"></a>摊还分析与Splay的复杂度证明</h3><p>势能分析并不是难在推导过程，那个其实非常简单，只需要把对应操作后的状态用势能函数表示一下，然后最后求和保证能消去即可。</p>
<p>难在理解势能函数。为什么势能函数是正确的，势能的单位不影响最后的结果，操作复杂度与势能的改变并不对应？</p>
<p>势能分析并不将预付代价表示为数据结构中特定对象的信用，而是表示为势能。一个势能函数将一个数据结构的状态映射为一个实数。</p>
<p>如果设$i$时刻的数据结构状态是$D_i$，势能函数映射的势能是$\phi(D_i)$，</p>
<p>一次操作的实际代价$\hat c<em>i = c_i + \phi(D_i) - \phi(D</em>{i-1})$</p>
<p>当$\phi(D<em>i)-\phi(D</em>{i-1})$大于0，意味着提前支付了费用，相反的，则意味着少支付了费用。</p>
<p><del>以前我正好弄反了，结果就学不会了</del></p>
<p><del>不过知道了正确定义后反而感觉没法感性理解了，那就再学习下吧</del></p>
<p>进入Splay证明正式阶段</p>
<p><del>几乎抄袭自Mr.Spade</del></p>
<p>本文用势能法证明Splay的均摊复杂度，对Splay的具体操作不进行讲述。</p>
<p>为了方便本文的描述，定义如下内容：</p>
<p>在文中我们用$T$表示一棵完整的Splay，并（不严谨地）用$|T|$表示$T$这棵Splay的节点数目。</p>
<p>如无特殊说明，小写英文字母（如x，y，z）在本文中表示T的一个节点，并（不严谨地）用$|x|$表示以节点$x$为根的子树的大小，$x \in T$表示节点x在T中。</p>
<p>一般我们默认$x′$代表节点$x$在经过了上下文中描述的操作以后的状态，因此对应的x代表之前的状态。</p>
<p>我们用$\phi(T)$表示整棵Splay的势能函数，$\phi(x)$则表示节点x对T贡献的势能。</p>
<p>我们这么定义势能函数：</p>
<p>$\phi(x) = log_2|x|$</p>
<p>$\Phi(T) = \sum_{x \in T}\phi(x)$</p>
<p>可以发现，对于任意时刻，因为$|x|≥1$，因此$log|x|≥0$，从而得到$\Phi(T)≥0$，因此势能函数是合法的。同时$\forall |x|≤|T|$，因此我们总有$\Phi(T)≤|T|log|T|$。这个上界是比较松的，但是对我们的分析没有影响。</p>
<p>下面考虑一次伸展操作对于势能函数的影响。由于我们可以把从根向下查找的代价计算到伸展过程中对应的旋转操作上，此时旋转操作复杂度不变，只是常数增大，从而忽略了查找对复杂度的影响。我们可以简单地通过增大势的单位来支配隐藏在操作中的常数。因此我们只需证明对于一次伸展操作的所有旋转操作，其复杂度是均摊$O(log|T|)$的，我们就完成了对Splay复杂度的证明。</p>
<p>1、zig操作</p>
<p><img src="/images/splay_t_1.png" alt="img"></p>
<p>由于zag操作与zig相似，因此只需要证明zig即可。</p>
<p>假设我们zig的对象是x，其父亲为y，显然在旋转以后，只有x和y的子树大小发生了变化。因此势能变化量为：</p>
<p>$\delta \phi(T)=\phi(x′)+\phi(y′)−\phi(x)−\phi(y)$</p>
<p>显然$\phi(x′)=\phi(y)$，且\phi(x′)≥\phi(y′)，因此消去$\phi(x′)$与$\phi(y)$，并将$\phi(y′)$替换为$\phi(x′)$，有：</p>
<p>$\delta \phi(T)≤\phi(x′)−\phi(x)$</p>
<p>因此zig操作的均摊代价为$O(1+\phi(x′)−\phi(x))$，其中$O(1)$代表旋转操作本身的复杂度，而在一次伸展操作中也只会有一次zig操作，因此这额外的$O(1)$代价不会对分析造成影响，因此我们可以只关心其中的$O(\phi(x′)−\phi(x))$。</p>
<p>2、zig−zig操作</p>
<p><img src="/images/splay_t_2.png" alt="img"></p>
<p>由于zag−zag操作与zig−zig相似，因此只需要证明zig−zig即可。</p>
<p>假设我们zig−zig的对象是x，其父亲为y，其祖父为z，与zig操作类似，势能变化量为：</p>
<p>$\delta \phi(T)=\phi(x′)+\phi(y′)+\phi(z′)−\phi(x)−\phi(y)−\phi(z)$</p>
<p>同样地，由于$\phi(x′)=\phi(z)$，因此将它们消去：</p>
<p>$\delta \phi(T)=\phi(y′)+\phi(z′)−\phi(x)−\phi(y)$</p>
<p>而我们又有$\phi(x′)≥\phi(y′)，\phi(x)≤\phi(y)$，因此有：</p>
<p>$\delta \phi(T)≤\phi(x′)+\phi(z′)−2\phi(x)$</p>
<p>推到这里，我们先来做一个小工作，来证明$\phi(x)+\phi(z′)−2\phi(x′)$（注意与上面的式子不一样）的值不大于−1。</p>
<p>假设$|x|=a，|z′|=b$，那么我们有：</p>
<p>$\phi(x)+\phi(z′)−2\phi(x′)=log|x|+log|z′|−2log|x′|$</p>
<p>我们将log合并，得到：</p>
<p>$\phi(x)+\phi(z′)−2\phi(x′)=log(\frac{|x||z′|}{|x′|^2})$</p>
<p>由于$|x′|≥a+b$（可以结合旋转过程思考一下），而$log$是单调的，因此：</p>
<p>$\phi(x)+\phi(z′)−2\phi(x′)≤log(\frac{ab}{(a+b)^2})≤log(\frac{ab}{2ab})≤−1$</p>
<p>证明完毕。现在我们已经知道zig−zig操作的摊还代价不大于：</p>
<p>$O(1)+\phi(x′)+\phi(z′)−2\phi(x)$</p>
<p>其中O(1)为旋转操作的复杂度。由于之前的推导我们可以知道\phi(x)+\phi(z′)−2\phi(x′)≤−1，因此−1−$(\phi(x)+\phi(z′)−2\phi(x′))≥0$，我们在摊还代价上加上这个非负数得到：</p>
<p>$O(1)+\phi(x′)+\phi(z′)−2\phi(x)−1−(\phi(x)+\phi(z′)−2\phi(x′))$</p>
<p>化简一下，就得到：</p>
<p>$O(1)+O(\phi(x′)−\phi(x))−1$</p>
<p>通过增大我们刚刚加的那个非负数以及势的单位，我们就可以支配隐藏在O(1)中的常数，因此一次zig−zig操作的摊还代价为：</p>
<p>$O(\phi(x′)−\phi(x))$</p>
<p>3、zig−zag操作</p>
<p><img src="/images/splay_t_3.png" alt="img"><br>分析的过程和zig−zig操作完全一样，之前分析用到的所有性质此时仍然适用，因此略过分析过程。其摊还代价依然为：</p>
<p>$O(\phi(x′)−\phi(x))$</p>
<p>4、总结</p>
<p>综上所述，除了最后一次旋转可能增加$O(1)$的代价以外，其余操作的摊还代价只和我们伸展的对象$x$的势有关。<strong>我们假设旋转操作一共执行了$n$次</strong>，并用xi来表示节点x在经过i次旋转后的状态，那么整一个伸展操作的摊还代价就为：</p>
<p>$O(1+\sum<em>{i=1}^n\phi(x_i)−\phi(x</em>{i−1}))$</p>
<p>显然除了$\phi(x_n)$与$\phi(x_0)$外，所有的势都被抵消了，因此摊还代价为：</p>
<p>$O(1+\phi(x_n)−\phi(x0))$</p>
<p>至此，我们不必关心$\phi(x_0)$的值了。此时$x_n$是整棵Splay的根，因此$\phi(x_n)=log|T|$。我们成功的证明了一次伸展操作的摊还代价为$O(log|T|)$。</p>
<p>但是我有个问题就是整个分析根本不考虑Splay时旋转操作的顺序，换句话说就是不考虑单双旋，好像只要上述任意一组旋转都能这么分析？…<del>不过暂时就这样先咕咕咕这个问题了</del></p>
<hr>
<h2 id="辅助树"><a href="#辅助树" class="headerlink" title="辅助树"></a>辅助树</h2><ul>
<li>我们刚才在说的建树方法，其实就是辅助树的建树方法，我们先来 看⼀看辅助树的一些性质，再通过一张图实际了解一下辅助树的具体结构。</li>
<li>每⼀个 Splay 维护的是一条路径，并且在原树中所有节点深度严格递增，并且，中序遍历这棵 Splay 得到的点序列列的点深度严格递增<strong>（即Splay按照深度为键值建树）</strong>。</li>
<li>每个节点包含且仅包含于一棵 Splay 中。</li>
<li>⼀棵 Splay 的根节点的 Father 指向它在辅助树中的父亲结点。但是它父亲结点的 ch 并没有指向这个点的。即父亲不不⼀定认⼉子，⽽⼉子能找到⽗亲。</li>
<li>由于 LCT 的 Access 操作（后面会解释），使得 3. 中的⽗亲不认⼉子对答案⽆任何影响，同时，也使一些叶⼦结点单独构成一棵 Splay 辅助树成为可能</li>
<li>由于辅助树的以上性质，我们维护任何操作都不需要维护原树，辅助树可以在任何情况下拿出一个唯一的原树，我们只需要维护辅助树即可。</li>
</ul>
<p>在本文里，你可以认为一些 Splay 构成了一个辅助树，每棵辅助树维护的是一棵树，一些辅助树构成了 LCT，其维护的是整个森林。</p>
<p>一个Example</p>
<p><img src="/images/lct_1.png" alt="img"></p>
<p>它的辅助树应该是这样的</p>
<p><img src="/images/lct_2.png" alt="img"></p>
<h2 id="考虑原树和辅助树的结构关系"><a href="#考虑原树和辅助树的结构关系" class="headerlink" title="考虑原树和辅助树的结构关系"></a>考虑原树和辅助树的结构关系</h2><p>原树中的实链 : 在辅助树中节点都在一棵 Splay 中</p>
<p>原树中的虚链 : 在辅助树中，子节点所在 Splay 的 Father 指向父节点，但是父节点的两个儿子都不指向子节点。</p>
<p>注意：<strong>原树的根 ≠ 辅助树的根。</strong></p>
<p><strong>原树的 Father 指向 ≠ 辅助树的 Father 指向。</strong></p>
<p>辅助树是可以在满足辅助树、Splay 的性质下任意换根的。</p>
<p>虚实链变换可以轻松在辅助树上完成，这也就是实现了动态维护树链剖分。</p>
<p><strong>一颗Splay的根节点指向的点是这颗Splay里深度最浅的点在原树上的父亲对应的辅助树的点</strong></p>
<h2 id="接下来要用到的变量声明"><a href="#接下来要用到的变量声明" class="headerlink" title="接下来要用到的变量声明"></a>接下来要用到的变量声明</h2><ul>
<li><code>ch[N][2]</code> 左右⼉子</li>
<li><code>f[N]</code> ⽗亲指向</li>
<li><code>sum[N]</code> 路径权值和</li>
<li><code>val[N]</code> 点权</li>
<li><code>tag[N]</code> 翻转标记</li>
<li><code>laz[N]</code> 权值标记</li>
<li>Other_Vars</li>
</ul>
<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><h4 id="⼀般数据结构函数（字面意思）"><a href="#⼀般数据结构函数（字面意思）" class="headerlink" title="⼀般数据结构函数（字面意思）"></a>⼀般数据结构函数（字面意思）</h4><ol>
<li>$PushUp(x)$</li>
<li>$PushDown(x)$</li>
</ol>
<h4 id="Splay-系函数（不会多做解释）"><a href="#Splay-系函数（不会多做解释）" class="headerlink" title="Splay 系函数（不会多做解释）"></a>Splay 系函数（不会多做解释）</h4><ol>
<li>$Get(x) $获取 x 是父亲的哪个⼉子。</li>
<li>$Splay(x) $通过和 Rotate 操作联动实现把 x 旋转到当前 Splay 的根。</li>
<li>$Rotate(x)$ 将$ x $向上旋转一层的操作。</li>
</ol>
<h4 id="新操作"><a href="#新操作" class="headerlink" title="新操作"></a>新操作</h4><ol>
<li>$IsRoot(x)$ 判断当前节点是否是所在 Splay 的根</li>
<li>$Access(x) $把从根到当前节点的所有点放在⼀条实链里，使根到它成为一条实路径，并且在同一棵 Splay 里里。</li>
<li>$Update(x)$ 在$ Access $操作之后，递归的从上到下 $Pushdown $更新信 息。</li>
<li>$MakeRoot(x)$ 使 x 点成为整个辅助树的根。</li>
<li>$Link(x, y)$ 在 $x, y$ 两点间连⼀一条边。</li>
<li>$Cut(x, y)$ 把$ x, y $两点间边删掉。</li>
<li>$Find(x)$ 找到$ x$ 所在的$ Splay $的根节点编号。</li>
<li>$Fix(x, v) $修改 $x$ 的点权为$ v$。</li>
<li>$Split(x, y) $提取出来$ x, y $间的路路径，⽅方便便做区间操作</li>
</ol>
<h2 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h2><p>$PushUp(x)$(严格$O(1)$)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	s[x] = s[ch[<span class="number">0</span>][x]] ^ s[ch[<span class="number">1</span>][x]] ^ v[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下推取反标记也不可少</p>
<p>$pushrev(x)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushrev</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::swap(ch[<span class="number">0</span>][x] , ch[<span class="number">1</span>][x]) , rev[x] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$PushDown(x)$(严格$O(1)$)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__tag1[p] != std_tag1) &#123;</span><br><span class="line">    &lt; <span class="keyword">do</span> ls &amp; <span class="keyword">do</span> rs &gt; </span><br><span class="line">    __tag1[p] = std_tag1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$Splay(x) \and Rotate(x)$ (均摊$O(logn)$)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Get(x) (ch[f[x]][1] == x)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> y = f[x] , z = f[y] , k = ch[<span class="number">1</span>][y] == x , sn = ch[!k][x];</span><br><span class="line">	<span class="keyword">if</span>(nroot(y)) ch[ch[<span class="number">1</span>][z]==y][z] = x ;</span><br><span class="line">   	ch[!k][x] = y , ch[k][y] = sn;</span><br><span class="line">	<span class="keyword">if</span>(sn) f[sn] = y ;</span><br><span class="line">   	f[y] = x , f[x] = z;</span><br><span class="line">	pushup(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> y = x , z = <span class="number">0</span>;</span><br><span class="line">	st[++z] = y;</span><br><span class="line">	<span class="keyword">while</span>(nroot(y)) st[++z] = y = f[y];</span><br><span class="line">	<span class="keyword">while</span>(z) pushdown(st[z--]);</span><br><span class="line">	<span class="keyword">while</span>(nroot(x))</span><br><span class="line">	&#123;</span><br><span class="line">		y = f[x] , z = f[y];</span><br><span class="line">		<span class="keyword">if</span>(nroot(y))</span><br><span class="line">			rotate((ch[<span class="number">0</span>][y] == x)^(ch[<span class="number">0</span>][z] == y)? x : y);</span><br><span class="line">		rotate(x);</span><br><span class="line">	&#125;</span><br><span class="line">	pushup(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上大概都是前置知识非常简单的实现。。<br>接下来实现LCT的基础函数及功能函数</p>
<p>$isRoot(x)$(严格$O(1)$)<br>在前面我们已经说过，LCT 具有 如果一个儿子不是实儿子，他的父亲找不到它的性质<br>所以当一个点既不是它父亲的左儿子，又不是它父亲的右儿子，它就是当前 Splay 的根</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isRoot(x) (ch[f[x]][0] != x &amp;&amp; ch[f[x]][1] != x)</span></span><br></pre></td></tr></table></figure>
<p>$Access(x)$(均摊$O(logn)$)</p>
<p>这是LCT的核心操作，后面的大部分操作都依赖于它。</p>
<p>我们需要让给定节点到当前根上的路径都是重边。<strong>我们想求解一条路径，而这条路径恰好就是我们当前的一棵 Splay</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span> ; x ; y = x , x = f[x])</span><br><span class="line">		splay(x) , ch[<span class="number">1</span>][x] = y , pushup(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如（其实我根本没看底下这个例子）<br>我们有这样一棵树，实线为实边，虚线为虚边<br><img src="/images/lct_3.png" alt="img"><br>它的辅助树可能长成这样（构图方式不同可能 LCT 的结构也不同）<br>每个绿框里是一棵 Splay。<br><img src="/images/lct_4.png" alt="img"></p>
<p>现在我们要 Access(N), 把 A-N 的路径都变实，拉成一棵 Splay<br><img src="/images/lct_5.png" alt="img"></p>
<p>实现的方法是从下到上逐步更新 Splay<br>首先我们要把 N 旋至当前 Splay 的根。<br>为了保证 AuxTree 的性质，原来 N——O 的实边要更改为虚边。<br>由于认父不认子的性质，我们可以单方面的把 N 的儿子改为 Null。<br>于是原来的 Aux 就从下图变成了下下图。</p>
<p><img src="/images/lct_10.png" alt="img"></p>
<p><img src="/images/lct_6.png" alt="img"></p>
<p>下一步，我们把 N 指向的 Father-&gt; I 也旋转到它 (I) 的 Splay 树根。</p>
<p>原来的实边 I——K 要去掉，这时候我们把 I 的右儿子指向 N, 就得到了 I——L 这样一棵 Splay。</p>
<p><img src="/images/lct_7.png" alt="img"></p>
<p>接下来，按照刚刚的操作步骤，由于 I 的 Father 指向 H, 我们把 H 旋转到他所在 Splay Tree 的根，然后把 H 的 rs 设为 I。</p>
<p>之后的树是这样的。</p>
<p><img src="/images/lct_8.png" alt="img"></p>
<p>同理我们 Splay(A) , 并把 A 的右儿子指向 H。<br>于是我们得到了这样一棵 AuxTree。并且发现 A——N 的整个路径已经在同一棵 Splay 中了。大功告成！<br><img src="/images/lct_9.png" alt="img"></p>
<p>我们发现 Access() 其实很容易。只有如下四步操作：</p>
<ol>
<li>把当前节点转到根。</li>
<li>把儿子换成之前的节点。</li>
<li>更新当前点的信息。</li>
<li>把当前点换成当前点的父亲，继续操作。</li>
</ol>
<p><strong>注意转Splay的顺序是按深度递增的，所以每次都是设置右儿子（我甚至想了一会）</strong></p>
<h2 id="UPD"><a href="#UPD" class="headerlink" title="UPD"></a>UPD</h2><p>这里似乎并不是很好懂，或者说我之后写代码发现又不明白了，所以我决定在这里说明这个做法到底是怎么一回事。</p>
<p>首先我们从$x$开始到上一颗Splay，然后这时$x$右儿子应该是不存在的因为在$x$的Splay中，<strong>它是最深的，Splay的键值就是深度</strong>。</p>
<p>后面的也好想，我们将一个点Splay到根后Splay的性质完全没有变化，这时我们跳到它的父亲$fx$，显然此时$fx$同样是Splay中的最深点（<strong>深度肯定是连续的，因为只隔了一条边</strong>），将它转到根上这个Splay也是正确的。</p>
<p>那么这两颗Splay应该在一起，怎么做呢？<strong>它的右儿子设为上一次Splay的根即可完成正确的合并</strong>，因为比当前的根深度大的点（即右儿子和右子树）显然不在$access$的路径中，所以右儿子应设置为深度大的Splay的根，这样中序遍历原先虚边链接的两个点是深度相邻的，这么做恰好就是相邻的。</p>
<p>其实这个不难想。主要是理解平衡树的中序遍历始终是有序的一个序列（这里就是按深度来的一个有序点集），然后我们把两个这东西合起来完全可以直接让根键值小的右儿子置为根键值大的Splay的根。<del>平衡树没学好想半天退役吧</del></p>
<p>只需要说明两颗的情况，后面每一颗与之前的构成的两颗都相当于被归纳说明了。</p>
<p><del>真啰嗦</del></p>
<p>主要是不要忘了就好。</p>
<p><strong>可以使用手工栈+迭代来减小常数</strong></p>
<p>重要操作又来了</p>
<p><strong>$makeroot(x)$</strong></p>
<p>这个函数的作用是使LCT维护以$x$为根的树（森林）</p>
<p>$MakeRoot()$ 的重要性丝毫不亚于 $Access()$。我们在需要维护路径信息的时候，一定会出现路径深度无法严格递增的情况（也就是说LCA不是两点中的一个），根据 $Aux $的性质，这种路径是不能出现在一棵$ Splay $中的。<br>这时候我们需要用到$ MakeRoot()$。<br>$MakeRoot()$的作用是使指定的点成为原树的根，考虑如何实现这种操作。<br>我们发现$ Access(x) $后，$x$ 在$ Splay$ 中一定是深度最大的点（从根到 $x$, 深度严格递增）。<br>而变成根即是变成深度最小的点。我们 $Splay(x) $ , 发现这时候$ x $并没有右子树（即所有点深度都比它浅）。那我们把$ x $的左右儿子交换一下，变成了$ x $没有左子树，在 $Aux $意义上就是深度最小的点了，即达到目的。<br>所以我们交换左右儿子，并给右儿子打一个翻转标记即可。（此时左儿子没有值）。</p>
<p>整个流程：</p>
<ol>
<li>$Access(x)$</li>
<li>$Splay(x)$</li>
<li>tag(x) ^= 1(翻转标记)<br> 也就是说由于$x$经过$Access$后深度最大，所以我们把它$Splay$旋转到根，然后整条实链上的深度都反过来了，因为我们按照深度建树，所以相当于区间翻转了，打一个$Lazytag$即可。<strong>而其它实链是不需要处理的，它们并不受到影响，相对关系并没有变，也不需要做什么操作</strong><br> <strong>简单概括就是换根后其它实链上的点相对关系并没有变（他们之间的联系要么连在这条链上，要么连在其它链上，所以只需要处理这一条链即可）</strong></li>
</ol>
<p><del>浪费一下午想抛弃typora，结果失败了，活该，我爱typora一辈子</del></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	access(x) , splay(x) , pushrev(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$findroot(x)$</p>
<p>用来查询<strong>实际树</strong>里的根，$link$和$cut$也需要判断连边是否合法。（map也行不过不一定快）</p>
<p><strong>可以判断两点$x,y$是否在同一颗树里.</strong>先$Access(x)$ , 然后$find(y)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	access(x) , splay(x);</span><br><span class="line">	<span class="keyword">while</span>(ch[<span class="number">0</span>][x]) pushdown(x) , x = ch[<span class="number">0</span>][x];</span><br><span class="line">	splay(x);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$Link(x)$</p>
<p>$Link$ 两个点其实很简单，先 $Make_Root(x)$ , 然后把$ x $的父亲指向$ y $即可。显然，这个操作肯定不能发生在同一棵树内。记得先判一下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	makeroot(x);</span><br><span class="line">	<span class="keyword">if</span>(findroot(y) != x) f[x] = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$cut(x ,y)$</p>
<p>注意一堆特判。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	makeroot(x);</span><br><span class="line">	<span class="keyword">if</span>(findroot(y) == x &amp;&amp; f[y] == x &amp;&amp; !ch[<span class="number">0</span>][y])</span><br><span class="line">		ch[<span class="number">1</span>][x] = f[y] = <span class="number">0</span> , pushup(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$Split(x,y)$</p>
<p>有Splay维护区间基本经验应该就很容易接受。</p>
<p>先$Makeroot(x)$然后$Access(y)$，此时这条链已经在一个Splay中，在这个过程中时刻维护子树信息，（用最开头那个pushup和pushdown就可以）最后取根上的答案。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	makeroot(x) , access(y) , splay(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想起来很简单就是不知道写的时候怎么样了。</p>
<p>似乎LCT并不难，都是些很好理解的操作？</p>
<p>那你会证明复杂度吗？</p>
<h2 id="正确性分析"><a href="#正确性分析" class="headerlink" title="正确性分析"></a>正确性分析</h2><p>这个数据结构各个操作的正确性似乎显然。。。</p>
<p>关于标记的正确性我也不知道该怎么说，就是对的。<del>烦</del></p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>From Remoon</p>
<p>其实最好的证明是开头那篇原始论文的证明，比较懒就看的remoon的，不过思想好像是一样的。</p>
<p>我们只证明$Access(x)$的复杂度。（每个函数都会影响势能但是我们只需要分析一个，真神奇）</p>
<ol>
<li>首先是在Splay中走的复杂度。</li>
</ol>
<p>定义$w(x)=log<em>2(|x|)$ ， $\varphi = \sum</em>{x \in T}w(x)$</p>
<p>设它依次访问了$x_1,x_2….x_p$</p>
<p>那么，类似上文$splay$的复杂度分析，我们可以得到总的一次势能变化量为（为什么是加1啊）</p>
<p>他的势能改变量$\Delta \varphi = -w(x_1) + w(x_2) - w(x_2) + w(x_3)…… + w(x_p) + 1 \leq  w(x_p) + 1 = O(logn)$</p>
<p>据说这叫Splay的finger-search性质。去看了下wiki</p>
<p><a href="https://en.wikipedia.org/wiki/Finger_search" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Finger_search</a></p>
<p>初始的势能也是需要考虑在内的。总复杂度为</p>
<p>$O((n+m)logn)$</p>
<ol>
<li>访问更改虚边的复杂度</li>
</ol>
<p>还是有时间看原版论文吧。</p>
<p>也许可以参考下Wiki？<br><a href="https://en.wikipedia.org/wiki/Link/cut_tree" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Link/cut_tree</a></p>
<p>开头那篇是原版的，有点模糊。</p>
<p>找到一个分析上更简洁也更清楚的</p>
<p><a href="/download/LCT.pdf">LCT.pdf</a></p>
<p>和Wiki基本一样。</p>
<p>这个讲的就不错了，确实和remoon一样用的HLD来分析。</p>
<p><del>那我就懒得抄一遍markdown了</del></p>
<p>我甚至发现我有一份180页的Toptree论文，我知道我放了我也不会看的。</p>
<p><a href="/download/Design_and_Analysis_of_Data_Structures_for_Dynamic_Trees.pdf">Design_and_Analysis_of_Data_Structures_for_Dynamic_Trees.pdf</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>唯一的教训就是小心压行！！！！！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 300005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> st[maxn] , ch[<span class="number">2</span>][maxn], f[maxn] , v[maxn] , s[maxn] , rev[maxn] , n , m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">nroot</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ch[<span class="number">0</span>][f[x]] == x || ch[<span class="number">1</span>][f[x]] == x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	s[x] = s[ch[<span class="number">0</span>][x]] ^ s[ch[<span class="number">1</span>][x]] ^ v[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushrev</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::swap(ch[<span class="number">0</span>][x] , ch[<span class="number">1</span>][x]) , rev[x] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!rev[x]) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(ch[<span class="number">0</span>][x]) pushrev(ch[<span class="number">0</span>][x]);</span><br><span class="line">	<span class="keyword">if</span>(ch[<span class="number">1</span>][x]) pushrev(ch[<span class="number">1</span>][x]);</span><br><span class="line">	rev[x] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> y = f[x] , z = f[y] , k = ch[<span class="number">1</span>][y] == x , sn = ch[!k][x];</span><br><span class="line">	<span class="keyword">if</span>(nroot(y)) ch[ch[<span class="number">1</span>][z]==y][z] = x ;</span><br><span class="line">   	ch[!k][x] = y , ch[k][y] = sn;</span><br><span class="line">	<span class="keyword">if</span>(sn) f[sn] = y ;</span><br><span class="line">   	f[y] = x , f[x] = z;</span><br><span class="line">	pushup(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> y = x , z = <span class="number">0</span>;</span><br><span class="line">	st[++z] = y;</span><br><span class="line">	<span class="keyword">while</span>(nroot(y)) st[++z] = y = f[y];</span><br><span class="line">	<span class="keyword">while</span>(z) pushdown(st[z--]);</span><br><span class="line">	<span class="keyword">while</span>(nroot(x))</span><br><span class="line">	&#123;</span><br><span class="line">		y = f[x] , z = f[y];</span><br><span class="line">		<span class="keyword">if</span>(nroot(y))</span><br><span class="line">			rotate((ch[<span class="number">0</span>][y] == x)^(ch[<span class="number">0</span>][z] == y)? x : y);</span><br><span class="line">		rotate(x);</span><br><span class="line">	&#125;</span><br><span class="line">	pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span> ; x ; y = x , x = f[x])</span><br><span class="line">		splay(x) , ch[<span class="number">1</span>][x] = y , pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	access(x) , splay(x) , pushrev(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	access(x) , splay(x);</span><br><span class="line">	<span class="keyword">while</span>(ch[<span class="number">0</span>][x]) pushdown(x) , x = ch[<span class="number">0</span>][x];</span><br><span class="line">	splay(x);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	makeroot(x) , access(y) , splay(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	makeroot(x);</span><br><span class="line">	<span class="keyword">if</span>(findroot(y) != x) f[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	makeroot(x);</span><br><span class="line">	<span class="keyword">if</span>(findroot(y) == x &amp;&amp; f[y] == x &amp;&amp; !ch[<span class="number">0</span>][y])</span><br><span class="line">		ch[<span class="number">1</span>][x] = f[y] = <span class="number">0</span> , pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++i)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;v[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">//	print();</span></span><br><span class="line">		<span class="keyword">int</span> op , x , y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;op,&amp;x,&amp;y);</span><br><span class="line">		<span class="keyword">if</span>(!op) split(x,y) , <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,s[y]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">1</span>) link(x,y);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>) cut(x,y);</span><br><span class="line">		<span class="keyword">else</span> splay(x) , v[x] = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/LCT/" rel="tag"># LCT</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/31/2019.3.31/" rel="next" title="Post 80">
                <i class="fa fa-chevron-left"></i> Post 80
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/07/SDOI2019/" rel="prev" title="SDOI 2019">
                SDOI 2019 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80MzY3Ny8yMDIxNw=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">wavwing</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">195</span>
                    <span class="site-state-item-name">Artikel</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">120</span>
                    <span class="site-state-item-name">Tags</span>
                  
                </div>
              
            </nav>
          

          

          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Orz!
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/forever_shi" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;forever_shi" rel="noopener" target="_blank">forever_shi</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://ctz45562.github.io/" title="https:&#x2F;&#x2F;ctz45562.github.io&#x2F;" rel="noopener" target="_blank">CST_Orz</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#LCT-Note"><span class="nav-number">1.</span> <span class="nav-text">LCT Note</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Preface"><span class="nav-number">1.1.</span> <span class="nav-text">Preface</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态树原始问题："><span class="nav-number">1.1.1.</span> <span class="nav-text">动态树原始问题：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前置知识篇"><span class="nav-number">1.2.</span> <span class="nav-text">前置知识篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实链剖分"><span class="nav-number">1.2.1.</span> <span class="nav-text">实链剖分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Splay"><span class="nav-number">1.3.</span> <span class="nav-text">Splay</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Splay基本操作"><span class="nav-number">1.3.1.</span> <span class="nav-text">Splay基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量声明："><span class="nav-number">1.3.2.</span> <span class="nav-text">变量声明：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【clear操作】"><span class="nav-number">1.3.3.</span> <span class="nav-text">【clear操作】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【get操作】"><span class="nav-number">1.3.4.</span> <span class="nav-text">【get操作】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【update操作】："><span class="nav-number">1.3.5.</span> <span class="nav-text">【update操作】：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【旋转操作】："><span class="nav-number">1.3.6.</span> <span class="nav-text">【旋转操作】：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【Splay操作】"><span class="nav-number">1.3.7.</span> <span class="nav-text">【Splay操作】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【insert操作】"><span class="nav-number">1.3.8.</span> <span class="nav-text">【insert操作】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【find操作】"><span class="nav-number">1.3.9.</span> <span class="nav-text">【find操作】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【findx操作】"><span class="nav-number">1.3.10.</span> <span class="nav-text">【findx操作】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【pre-next操作】"><span class="nav-number">1.3.11.</span> <span class="nav-text">【pre/next操作】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【del操作】"><span class="nav-number">1.3.12.</span> <span class="nav-text">【del操作】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Splay区间翻转"><span class="nav-number">1.3.13.</span> <span class="nav-text">Splay区间翻转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#摊还分析与Splay的复杂度证明"><span class="nav-number">1.3.14.</span> <span class="nav-text">摊还分析与Splay的复杂度证明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#辅助树"><span class="nav-number">1.4.</span> <span class="nav-text">辅助树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#考虑原树和辅助树的结构关系"><span class="nav-number">1.5.</span> <span class="nav-text">考虑原树和辅助树的结构关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接下来要用到的变量声明"><span class="nav-number">1.6.</span> <span class="nav-text">接下来要用到的变量声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数声明"><span class="nav-number">1.7.</span> <span class="nav-text">函数声明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#⼀般数据结构函数（字面意思）"><span class="nav-number">1.7.0.1.</span> <span class="nav-text">⼀般数据结构函数（字面意思）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Splay-系函数（不会多做解释）"><span class="nav-number">1.7.0.2.</span> <span class="nav-text">Splay 系函数（不会多做解释）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#新操作"><span class="nav-number">1.7.0.3.</span> <span class="nav-text">新操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数实现"><span class="nav-number">1.8.</span> <span class="nav-text">函数实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UPD"><span class="nav-number">1.9.</span> <span class="nav-text">UPD</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正确性分析"><span class="nav-number">1.10.</span> <span class="nav-text">正确性分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复杂度分析"><span class="nav-number">1.11.</span> <span class="nav-text">复杂度分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码"><span class="nav-number">1.12.</span> <span class="nav-text">代码</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      
    
      
    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wavwing</span>

  

  
</div>


 
</div>


  <div class="powered-by">Erstellt mit  <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.5.0</div>




        








        
      </footer></div>
    

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.5.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  
    <script type="text/javascript">
      window.livereOptions = {
        refer: '2019/03/31/LCT Note/'
      };
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

    
  


  
  

  

  

  

  

  

  

</body>
</html>
